# Approach
The key definition of height-balanced here is the left and right tree difference should be less than 1, and that difference is acceptable.  
We need to check all left and right branches at each sub tree to see if they are balanced.  
Here the recursive function is used and the way to define is, we need to think how to do only at this level, then each futher step takes the same approach as defined.  
So, we keep a dfs function within the method.  
This dfs has a base case: the node is None, so it is balanced and return height 0.  
dfs handles the left branch and right branch separately and then combine their returned results  
The left branch should have returned boolean, and its child branches height.  
The right branch also has the returned boolean from its child branches and its child branches height.  
Once their child branches return False, at current level, we return False.  
If they are balanced, we check returned child branches heights.  
Once, height difference is greater than 1, return False.  
If less than 1, current sub tree is acceptable as balanced. The key thing is here: we need to return the longer child branch height plus 1, which is an addon for current node height.  
Then, this current sub tree can return to previous level.  

# Cost
- Time: O(n), all nodes must be visited
- Space: O(h), where h is the tree height, if tree is balanced, O(log n), if tree is chained style, O(n), because we need to iterate until the leave level, then compare the height diff.